---
title: "Minting Tokens"
sidebarTitle: "Minting"
description: "Create new tokens and increase total supply."
"og:title": "Minting Tokens - Compact by Example"
"og:description": "Create tokens with overflow protection and supply management"
---

Minting creates new tokens and adds them to circulation.

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Account balances
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

// Total token supply
export ledger totalSupply: Uint<128>;

// Get total circulating supply
export circuit getTotalSupply(): Uint<128> {
    return totalSupply;
}

// Mint new tokens
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    _mint(account, amount);
}

// Internal: Mint tokens
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Check total supply won't overflow
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(totalSupply <= MAX_UINT128 - amount, "Total supply overflow");

    // Update total supply
    totalSupply = disclose(totalSupply + amount);

    // Get current balance
    const currentBalance = getBalance(account);

    // Check account balance won't overflow
    assert(currentBalance <= MAX_UINT128 - amount, "Balance overflow");

    // Increase account balance
    balances.insert(disclose(account), disclose(currentBalance + amount));
}

// Helper: Get balance
circuit getBalance(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!balances.member(disclose(account))) {
        return 0;
    }
    return balances.lookup(disclose(account));
}
```

</Accordion>

## How It Works

### Total Supply Tracking

```compact
export ledger totalSupply: Uint<128>;

export circuit getTotalSupply(): Uint<128> {
    return totalSupply;
}
```

Total supply represents all tokens in circulation:

- **Mint**: Increases total supply
- **Burn**: Decreases total supply (see [Burning tutorial](/basics/burning))
- **Transfer**: Doesn't change total supply (moves between accounts)

<Note>
  **Invariant**: `sum(all balances) == totalSupply` should always be true.
  Minting and burning are the only operations that change this.
</Note>

### Minting Process

```compact
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Check total supply won't overflow
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(totalSupply <= MAX_UINT128 - amount, "Total supply overflow");

    // Update total supply
    totalSupply = disclose(totalSupply + amount);

    // Get current balance
    const currentBalance = getBalance(account);

    // Check account balance won't overflow
    assert(currentBalance <= MAX_UINT128 - amount, "Balance overflow");

    // Increase account balance
    balances.insert(disclose(account), disclose(currentBalance + amount));
}
```

Minting flow:

1. **Check total supply overflow**: Ensure we don't exceed Uint\<128\> max (340,282,366,920,938,463,463,374,607,431,768,211,455)
2. **Increase total supply**: Add new tokens to circulation
3. **Get current balance**: Check recipient's current balance
4. **Check account overflow**: Ensure recipient balance won't overflow
5. **Credit account**: Add tokens to recipient's balance

**Result**: New tokens are created from nothing and added to an account.

<Warning>
  **Critical**: Always check BOTH total supply overflow AND account balance
  overflow. Forgetting either can corrupt state or cause transaction failures.
</Warning>

### Public vs Internal Functions

```compact
// Public: Anyone can call (should add access control!)
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    _mint(account, amount);
}

// Internal: Only callable within contract
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // ... minting logic
}
```

- **Public functions** (`export circuit`): Can be called externally - **add access control**!
- **Internal functions** (no `export`): Only used within the contract

<Warning>
  **Security Risk**: The example `mint()` function has NO access control. Anyone
  can mint unlimited tokens! In production, add owner-only or role-based access
  control to the mint function.
</Warning>

## Supply Management Patterns

### Capped Supply

```compact
export ledger MAX_SUPPLY: Uint<128>;

circuit constructor(): [] {
    MAX_SUPPLY = disclose(1000000 as Uint<128>); // Max 1 million tokens
}

circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Check against max supply cap
    assert(totalSupply + amount <= MAX_SUPPLY, "Exceeds max supply");

    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(totalSupply <= MAX_UINT128 - amount, "Total supply overflow");

    // ... rest of minting logic
    totalSupply = disclose(totalSupply + amount);

    const currentBalance = getBalance(account);
    assert(currentBalance <= MAX_UINT128 - amount, "Balance overflow");

    balances.insert(disclose(account), disclose(currentBalance + amount));
}
```

Enforce a hard cap on total supply (like Bitcoin's 21 million).

### Inflationary Tokenomics

```compact
export ledger lastInflation: Uint<64>;
export ledger inflationRate: Uint<8>; // Percentage

export circuit applyInflation(): [] {
    // Calculate time since last inflation
    const timePassed = getCurrentTime() - lastInflation;
    const DAY_IN_SECONDS = 86400 as Uint<64>;

    if (timePassed >= DAY_IN_SECONDS) {
        // Mint new tokens (e.g., 2% daily inflation)
        const inflation = (totalSupply * inflationRate as Uint<128>) / 100;

        const treasury = getTreasuryAddress();
        _mint(treasury, inflation);

        lastInflation = disclose(getCurrentTime());
    }
}
```

Automatic inflation for staking rewards or incentive programs.

### Owner-Only Minting

```compact
export ledger owner: Either<ZswapCoinPublicKey, ContractAddress>;

circuit constructor(): [] {
    owner = disclose(left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
}

export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Only owner can mint
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner can mint");

    _mint(account, amount);
}
```

Restrict minting to contract owner only.

### Initial Supply Distribution

```compact
circuit constructor(): [] {
    const founder1 = /* founder 1 address */;
    const founder2 = /* founder 2 address */;
    const treasury = /* treasury address */;

    // Initial distribution
    _mint(founder1, 100000); // 100k tokens to founder 1
    _mint(founder2, 100000); // 100k tokens to founder 2
    _mint(treasury, 800000); // 800k tokens to treasury

    // Total initial supply: 1 million tokens
}
```

Distribute initial token supply in constructor.

## Try It Yourself

<Accordion title="Build and Test">

**1. Create project:**

```bash
mkdir token-minting && cd token-minting
mkdir -p contracts
```

**2. Save the contract as `contracts/minting.compact`**

**3. Test minting:**

```compact
circuit testMinting(): [] {
    const alice = left<ZswapCoinPublicKey, ContractAddress>(/* alice's key */);
    const bob = left<ZswapCoinPublicKey, ContractAddress>(/* bob's key */);

    // Mint 1000 tokens to Alice
    _mint(alice, 1000);
    // Total supply: 1000, Alice: 1000

    // Mint 500 tokens to Bob
    _mint(bob, 500);
    // Total supply: 1500, Bob: 500

    // Mint more to Alice
    _mint(alice, 300);
    // Total supply: 1800, Alice: 1300

    // Verify supply matches sum of balances
    const sum = getBalance(alice) + getBalance(bob);
    assert(sum == totalSupply, "Supply mismatch!");
}
```

**4. Compile:**

```bash
compact compile contracts/minting.compact contracts/managed/minting
```

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Burning Tokens" icon="fire" href="/basics/burning">
    Learn how to destroy tokens
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    Complete token with minting
  </Card>
</CardGroup>
