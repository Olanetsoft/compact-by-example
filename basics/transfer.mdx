---
title: "Transfer Function"
sidebarTitle: "Transfer"
description: "Move tokens between accounts securely."
"og:title": "Transfer Function - Compact by Example"
"og:description": "Transfer tokens with authorization and balance validation"
---

Transfer tokens from one account to another with proper authorization and balance checks.Transfer Function"
sidebarTitle: "Transfer"
description: "Build a secure transfer function with authorization checks, balance validation, and safe state updates for moving tokens between accounts."
"og:title": "Transfer Function Tutorial - Compact by Example"
"og:description": "Transfer logic with authorization, validation, and safe balance updates"

---

<Info>
  **In this tutorial**: Authorization with ownPublicKey() • Balance validation •
  Overflow protection • Atomic updates • Zero-address checks
</Info>

## Introduction

The transfer function is the heart of any token system. It moves value from one account to another while ensuring the sender is authorized, has sufficient balance, and the receiver won't overflow. This pattern is fundamental to tokens, payments, and any value exchange system.

<Tip>
  **Real-world use**: Token transfers, payment systems, rewards distribution,
  marketplace transactions, or any application where value moves between
  accounts.
</Tip>

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Account balances
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

// Transfer tokens from sender to recipient
export circuit transfer(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): Boolean {
    // Get sender (caller of this function)
    const from = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Perform the transfer
    _transfer(from, to, amount);

    return true;
}

// Internal transfer logic
circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Get current balances
    const fromBalance = getBalance(from);
    const toBalance = getBalance(to);

    // Check sufficient balance
    assert(fromBalance >= amount, "Insufficient balance");

    // Check for overflow on receiver
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(toBalance <= MAX_UINT128 - amount, "Balance overflow");

    // Update balances atomically
    const newFromBalance = fromBalance - amount;
    const newToBalance = toBalance + amount;

    balances.insert(disclose(from), disclose(newFromBalance));
    balances.insert(disclose(to), disclose(newToBalance));
}

// Helper: Get balance (returns 0 if not found)
circuit getBalance(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!balances.member(disclose(account))) {
        return 0;
    }
    return balances.lookup(disclose(account));
}
```

</Accordion>

## How It Works

### Authorization with ownPublicKey()

```compact
export circuit transfer(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): Boolean {
    const from = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _transfer(from, to, amount);
    return true;
}
```

The `transfer()` function automatically uses the caller's identity:

- **`ownPublicKey()`**: Built-in function that returns the public key of whoever called this circuit
- **Implicit authorization**: No one can transfer from someone else's account
- **User calls `transfer(recipient, amount)`**: Their own address is automatically the sender

<Note>
  **Security**: Users never specify "from" in basic transfers. The contract gets
  it from `ownPublicKey()`, preventing unauthorized transfers.
</Note>

### Balance Checks

```compact
const fromBalance = getBalance(from);
assert(fromBalance >= amount, "Insufficient balance");
```

Verify the sender has enough tokens:

- **Read first**: Get current balance from Map
- **Validate**: Ensure sufficient funds
- **Clear error**: Tell user why transfer failed

### Overflow Protection

```compact
const toBalance = getBalance(to);
const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
assert(toBalance <= MAX_UINT128 - amount, "Balance overflow");
```

Prevent integer overflow on the receiver:

- **Maximum value**: Uint\<128\> can hold up to 340 undecillion
- **Overflow check**: Ensure addition won't wrap around
- **Safety first**: Better to reject than corrupt state

<Tip>
  **Why check overflow?** If `toBalance = MAX_UINT128` and you add 1, it wraps
  to 0. This could destroy tokens or create exploits.
</Tip>

### Atomic Updates

```compact
const newFromBalance = fromBalance - amount;
const newToBalance = toBalance + amount;

balances.insert(disclose(from), disclose(newFromBalance));
balances.insert(disclose(to), disclose(newToBalance));
```

Update both balances in sequence:

- **Calculate first**: Compute new values before writing
- **Write together**: Both updates happen in same transaction
- **All-or-nothing**: If one fails, entire transaction reverts

The transfer is atomic - either both accounts update or neither does.

## Transfer Patterns

### Self-Transfer Prevention

```compact
circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(from != to, "Cannot transfer to self");
    // ... rest of transfer logic
}
```

Some contracts block self-transfers to save gas or prevent confusion.

### Zero Amount Handling

```compact
circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    if (amount == 0) {
        return; // Allow zero transfers (no-op)
    }
    // ... rest of transfer logic
}
```

You can either allow or reject zero-amount transfers depending on your use case.

### Transfer with Events (Future)

```compact
// When Compact supports events/logs:
export circuit transfer(to: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): Boolean {
    const from = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _transfer(from, to, amount);

    // Emit event for indexers/explorers
    emitTransfer(from, to, amount);

    return true;
}
```

Events help off-chain systems track transfers without reading all state.

## Try It Yourself

<Accordion title="Build and Test">

**1. Create project:**

```bash
mkdir token-transfer && cd token-transfer
mkdir -p contracts
```

**2. Save the contract as `contracts/transfer.compact`**

**3. Add initialization:**

```compact
export ledger initialized: Boolean;

circuit constructor(): [] {
    // Give initial balances for testing
    const alice = left<ZswapCoinPublicKey, ContractAddress>(/* alice's key */);
    const bob = left<ZswapCoinPublicKey, ContractAddress>(/* bob's key */);

    balances.insert(disclose(alice), 1000);
    balances.insert(disclose(bob), 500);

    initialized = disclose(true);
}
```

**4. Add a balance query:**

```compact
export circuit myBalance(): Uint<128> {
    const me = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    return getBalance(me);
}
```

**5. Test transfers:**

```compact
// Alice transfers 100 tokens to Bob
// Alice calls: transfer(bob_address, 100)
// Result: Alice has 900, Bob has 600
```

**6. Compile:**

```bash
compact compile contracts/transfer.compact contracts/managed/transfer
```

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Token Approval" icon="check" href="/basics/approval">
    Grant permission for delegated transfers
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    Complete token with all features
  </Card>
</CardGroup>
