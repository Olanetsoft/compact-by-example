---
title: "Burning Tokens"
sidebarTitle: "Burning"
description: "Destroy tokens to reduce total supply."
"og:title": "Burning Tokens - Compact by Example"
"og:description": "Token burning for deflationary tokenomics and supply management"
---

Burning permanently destroys tokens, removing them from circulation.

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Account balances
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

// Total token supply
export ledger totalSupply: Uint<128>;

// Get total circulating supply
export circuit getTotalSupply(): Uint<128> {
    return totalSupply;
}

// Burn your own tokens
export circuit burn(amount: Uint<128>): [] {
    const account = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _burn(account, amount);
}

// Burn tokens from another account (with approval)
export circuit burnFrom(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    const spender = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Check and spend allowance (requires approval system)
    _spendAllowance(account, spender, amount);

    _burn(account, amount);
}

// Internal: Burn tokens
circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Get current balance
    const currentBalance = getBalance(account);

    // Check sufficient balance
    assert(currentBalance >= amount, "Burn amount exceeds balance");

    // Decrease account balance
    balances.insert(disclose(account), disclose(currentBalance - amount));

    // Decrease total supply
    totalSupply = disclose(totalSupply - amount);
}

// Helper: Get balance
circuit getBalance(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!balances.member(disclose(account))) {
        return 0;
    }
    return balances.lookup(disclose(account));
}

// Helper: Spend allowance (simplified - see Approval tutorial for full implementation)
circuit _spendAllowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Check allowance and decrease it
    // See Approval & Allowance tutorial for complete implementation
}
```

</Accordion>

## How It Works

### Burning Process

```compact
circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Get current balance
    const currentBalance = getBalance(account);

    // Check sufficient balance
    assert(currentBalance >= amount, "Burn amount exceeds balance");

    // Decrease account balance
    balances.insert(disclose(account), disclose(currentBalance - amount));

    // Decrease total supply
    totalSupply = disclose(totalSupply - amount);
}
```

Burning flow:

1. **Get current balance**: Check how many tokens account has
2. **Check sufficient balance**: Ensure account has enough tokens to burn
3. **Decrease account balance**: Remove tokens from account
4. **Decrease total supply**: Remove tokens from circulation

**Result**: Tokens are permanently destroyed and removed from total supply.

### Burning Your Own Tokens

```compact
export circuit burn(amount: Uint<128>): [] {
    const account = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _burn(account, amount);
}
```

Users can always burn their own tokens:

- **`ownPublicKey()`**: Automatically gets caller's address
- **Self-burn**: No approval needed to burn your own tokens
- **Deflationary**: Reduces circulating supply permanently
- **Voluntary**: Anyone can choose to burn their tokens

### Delegated Burning

```compact
export circuit burnFrom(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    const spender = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Check allowance (requires approval system)
    _spendAllowance(account, spender, amount);

    _burn(account, amount);
}
```

Burn someone else's tokens (with their approval):

- **Requires approval**: Account must first approve the burner (see [Approval tutorial](/basics/approval))
- **Useful for contracts**: Contracts that burn tokens as part of their logic
- **Spends allowance**: Decreases the approved amount

<Note>
  **Use case**: A staking contract that burns tokens when users stake, or a
  buyback contract that burns purchased tokens.
</Note>

## Try It Yourself

<Accordion title="Build and Test">

**1. Create project:**

```bash
mkdir token-burning && cd token-burning
mkdir -p contracts
```

**2. Save the contract as `contracts/burning.compact`**

**3. Test burning:**

```compact
circuit testBurning(): [] {
    const alice = left<ZswapCoinPublicKey, ContractAddress>(/* alice's key */);

    // Give Alice 1000 tokens
    balances.insert(disclose(alice), 1000);
    totalSupply = disclose(1000);

    // Alice burns 200 tokens
    _burn(alice, 200);
    // Total supply: 800, Alice: 800

    // Alice burns 300 more
    _burn(alice, 300);
    // Total supply: 500, Alice: 500

    // Verify supply matches balance
    assert(getBalance(alice) == totalSupply, "Supply mismatch!");
}
```

**4. Compile:**

```bash
compact compile contracts/burning.compact contracts/managed/burning
```

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Minting Tokens" icon="plus" href="/basics/minting">
    Learn how to create new tokens
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    Complete token with burning
  </Card>
</CardGroup>
