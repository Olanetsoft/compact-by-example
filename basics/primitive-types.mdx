---
title: "Primitive Types"
sidebarTitle: "Primitive Types"
description: "Basic data types: Uint, Field, Bytes, and Opaque."
"og:title": "Primitive Types - Compact by Example"
"og:description": "Uint, Field, Bytes, and Opaque types for zero-knowledge smart contracts"
---

Compact is statically typed - every value has a type that the compiler verifies.

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version 0.16;

import CompactStandardLibrary;

// Unsigned integers - bounded type
export ledger counter: Uint<0..1000>;

// Unsigned integers - sized type (32 bits)
export ledger balance: Uint<32>;

// Field element for ZK computations
export ledger commitment: Field;

// Fixed-length byte array
export ledger hash: Bytes<32>;

// Opaque type for private data
export ledger secretValue: Opaque<"string">;

export circuit updateCounter(newValue: Uint<0..1000>): [] {
  disclose(counter = newValue);
}

export circuit updateBalance(amount: Uint<32>): [] {
  disclose(balance = balance + amount);
}

export circuit storeCommitment(value: Field): [] {
  disclose(commitment = value);
}

export circuit storeHash(data: Bytes<32>): [] {
  disclose(hash = data);
}

export circuit updateSecret(secret: Opaque<"string">): [] {
  disclose(secretValue = secret);
}
```

</Accordion>

## How It Works

### Unsigned Integer Types - Bounded

```compact
export ledger counter: Uint<0..1000>;
```

**Bounded integer** `Uint<m..n>` represents values from `m` to `n` (inclusive). The lower bound `m` must be `0`, and `n` is a natural number.

<Note>
**Type Safety**: The compiler ensures you can't assign a value outside the bounds. For example, `Uint<0..255>` cannot hold the value 256.
</Note>

**Common bounds**:

- `Uint<0..255>` - single byte values
- `Uint<0..65535>` - two-byte values
- `Uint<0..4294967295>` - four-byte values (32-bit max)

### Unsigned Integer Types - Sized

```compact
export ledger balance: Uint<32>;
```

**Sized integer** `Uint<n>` uses up to `n` bits. This is equivalent to `Uint<0..m>` where `m = (2^n) - 1`.

**Common sizes**:

- `Uint<8>` = `Uint<0..255>` (1 byte)
- `Uint<16>` = `Uint<0..65535>` (2 bytes)
- `Uint<32>` = `Uint<0..4294967295>` (4 bytes)
- `Uint<64>` = `Uint<0..18446744073709551615>` (8 bytes)
- `Uint<256>` = very large numbers (32 bytes)

<Warning>
**Arithmetic Bounds**: When adding `Uint<0..m> + Uint<0..n>`, the result type is `Uint<0..m+n>`. Plan your bounds carefully to avoid exceeding the maximum unsigned integer value.
</Warning>

### Field Type

```compact
export ledger commitment: Field;
```

`Field` represents elements in the scalar prime field of the zero-knowledge proving system. Field arithmetic wraps around (modulo operation).

Used for:

- Hash function outputs
- Cryptographic commitments
- Zero-knowledge circuit computations
- Values that need modular arithmetic

Differences from Uint:

- `Field` arithmetic wraps around on overflow
- `Uint` subtraction checks for underflow at runtime
- `Uint<0..n>` is a subtype of `Field` for any `n`

### Bytes Type

```compact
export ledger hash: Bytes<32>;
```

`Bytes<n>` represents fixed-length byte arrays of exactly `n` bytes. Used for hashes, signatures, and binary data.

**Common lengths**:

- `Bytes<20>` - Ethereum-style addresses
- `Bytes<32>` - SHA-256 hashes, Ed25519 public keys
- `Bytes<64>` - Ed25519 signatures

String literals in Compact have type `Bytes<n>` where `n` is the UTF-8 byte length:

```compact
const message: Bytes<5> = "hello"; // UTF-8 encoding is 5 bytes
```

### Opaque Types

```compact
export ledger secretValue: Opaque<"string">;
```

`Opaque<tag>` types represent values that are **opaque to circuits** but can be manipulated by witnesses. In circuits, they're represented by their hash.

Allowed tags:

- `Opaque<"string">` - private strings
- `Opaque<"Uint8Array">` - private byte arrays

Opaque values let witnesses compute on private data without revealing it on-chain. The circuit only sees the hash.

### Boolean Type

```compact
const flag: Boolean = true;
```

`Boolean` has only two values: `true` and `false`. Used for conditions, flags, and logic.

**Default value**: `false`

## Try It Yourself

<Accordion title="Build and Compile">

**1. Create project structure:**

```bash
mkdir -p types-example/contracts
cd types-example
```

**2. Save the contract:**

Create `contracts/types.compact` with the code above.

**3. Compile:**

```bash
compact compile contracts/types.compact contracts/managed/types
```

**4. Observe the generated TypeScript types:**

Check `contracts/managed/types/contract/index.d.ts` to see how Compact types map to TypeScript:

- `Uint<n>` → `bigint` with runtime bounds checks
- `Field` → `bigint` with modular arithmetic
- `Bytes<n>` → `Uint8Array` with length checks
- `Opaque<"string">` → `string`
- `Boolean` → `boolean`

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Hello World" icon="hand-wave" href="/basics/hello-world">
    Apply types in your first contract
  </Card>
  <Card title="First App" icon="rocket" href="/basics/first-app">
    Build a counter with type safety
  </Card>
</CardGroup>
