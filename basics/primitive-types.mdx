---
title: "Primitive Types"
sidebarTitle: "Primitive Types"
description: "Basic data types: Uint, Field, Bytes, and Opaque."
"og:title": "Primitive Types - Compact by Example"
"og:description": "Uint, Field, Bytes, and Opaque types for zero-knowledge smart contracts"
---

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version 0.16;

import CompactStandardLibrary;

// Unsigned integers - bounded type
export ledger counter: Uint<0..1000>;

// Unsigned integers - sized type (32 bits)
export ledger balance: Uint<32>;

// Field element for ZK computations
export ledger commitment: Field;

// Fixed-length byte array
export ledger hash: Bytes<32>;

// Opaque type for private data
export ledger secretValue: Opaque<"string">;

export circuit updateCounter(newValue: Uint<0..1000>): [] {
  disclose(counter = newValue);
}

export circuit updateBalance(amount: Uint<32>): [] {
  disclose(balance = balance + amount);
}

export circuit storeCommitment(value: Field): [] {
  disclose(commitment = value);
}

export circuit storeHash(data: Bytes<32>): [] {
  disclose(hash = data);
}

export circuit updateSecret(secret: Opaque<"string">): [] {
  disclose(secretValue = secret);
}
```

</Accordion>

## How It Works

### Unsigned Integer Types - Bounded

```compact
export ledger counter: Uint<0..1000>;
```

`Uint<m..n>` represents values from `m` to `n` (inclusive). Lower bound must be `0`.

### Unsigned Integer Types - Sized

```compact
export ledger balance: Uint<32>;
```

`Uint<n>` uses up to `n` bits, equivalent to `Uint<0..(2^n - 1)>`.

### Field Type

```compact
export ledger commitment: Field;
```

Elements in the scalar prime field for zero-knowledge computations. Arithmetic wraps around (modulo).

### Bytes Type

```compact
export ledger hash: Bytes<32>;
```

Fixed-length byte arrays. `Bytes<n>` for exactly `n` bytes.

### Opaque Types

```compact
export ledger secretValue: Opaque<"string">;
```

Values opaque to circuits, represented by their hash. For private data.

### Boolean Type

```compact
const flag: Boolean = true;
```

Two values: `true` and `false`.

## Try It Yourself

<Accordion title="Build and Compile">

**1. Create project structure:**

```bash
mkdir -p types-example/contracts
cd types-example
```

**2. Save the contract:**

Create `contracts/types.compact` with the code above.

**3. Compile:**

```bash
compact compile contracts/types.compact contracts/managed/types
```

**4. Observe the generated TypeScript types:**

Check `contracts/managed/types/contract/index.d.ts` to see how Compact types map to TypeScript:

- `Uint<n>` → `bigint` with runtime bounds checks
- `Field` → `bigint` with modular arithmetic
- `Bytes<n>` → `Uint8Array` with length checks
- `Opaque<"string">` → `string`
- `Boolean` → `boolean`

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Hello World" icon="hand-wave" href="/basics/hello-world">
    Apply types in your first contract
  </Card>
  <Card title="First App" icon="rocket" href="/basics/first-app">
    Build a counter with type safety
  </Card>
</CardGroup>
