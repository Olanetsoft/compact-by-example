---
title: "Token Approval"
sidebarTitle: "Approval"
description: "Allow others to spend your tokens."
"og:title": "Token Approval - Compact by Example"
"og:description": "Token approvals for DEXs and delegated transfers"
---

The approval pattern lets you authorize another account to spend tokens on your behalf.

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Account balances
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

// Allowances: owner -> (spender -> amount)
export ledger allowances: Map<
    Either<ZswapCoinPublicKey, ContractAddress>,
    Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>
>;

// Approve spender to spend tokens on your behalf
export circuit approve(
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _approve(owner, spender, amount);
    return true;
}

// Check how much spender is allowed to spend
export circuit allowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>
): Uint<128> {
    if (!allowances.member(disclose(owner))) {
        return 0;
    }

    const spenderAllowances = allowances.lookup(disclose(owner));
    if (!spenderAllowances.member(disclose(spender))) {
        return 0;
    }

    return spenderAllowances.lookup(disclose(spender));
}

// Internal: Set approval
circuit _approve(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Initialize owner's allowance map if needed
    if (!allowances.member(disclose(owner))) {
        allowances.insert(
            disclose(owner),
            default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>
        );
    }

    // Set allowance for spender
    allowances.lookup(owner).insert(disclose(spender), disclose(amount));
}

// Helper
circuit getBalance(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!balances.member(disclose(account))) {
        return 0;
    }
    return balances.lookup(disclose(account));
}
```

</Accordion>

## How It Works

### Nested Map Structure

```compact
export ledger allowances: Map<
    Either<ZswapCoinPublicKey, ContractAddress>,
    Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>
>;
```

Allowances use a **Map of Maps** (nested structure):

- **Outer Map**: Owner address → Inner Map
- **Inner Map**: Spender address → Allowed amount

Example structure:

```
Alice → {
  DEX Contract → 1000 tokens,
  Bob → 50 tokens,
  Payment Processor → 100 tokens
}
Bob → {
  Subscription Service → 200 tokens
}
```

<Note>
  **Why nested?** Each owner can approve multiple spenders for different
  amounts. The nested structure tracks all these relationships efficiently.
</Note>

### Granting Approval

```compact
export circuit approve(
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _approve(owner, spender, amount);
    return true;
}
```

The approval flow:

1. **Owner calls** `approve(spender, amount)`
2. **Owner = ownPublicKey()**: Caller is automatically the owner
3. **Permission granted**: Spender can now spend up to `amount` tokens
4. **Returns true**: Standard ERC20 return value

**Example**: Alice calls `approve(DEX_CONTRACT, 1000)` - the DEX can now spend up to 1000 of Alice's tokens.

<Tip>
  **Multiple approvals**: You can approve different amounts for different
  spenders. Each approval is independent.
</Tip>

### Setting Approval Internally

```compact
circuit _approve(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Initialize owner's allowance map if needed
    if (!allowances.member(disclose(owner))) {
        allowances.insert(
            disclose(owner),
            default<Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>>
        );
    }

    // Set allowance for spender
    allowances.lookup(owner).insert(disclose(spender), disclose(amount));
}
```

Two-step process:

1. **Check if owner exists** in outer Map, create entry if not
2. **Insert spender amount** in owner's inner Map

This overwrites any previous approval for that spender.

### Checking Allowance

```compact
export circuit allowance(
    owner: Either<ZswapCoinPublicKey, ContractAddress>,
    spender: Either<ZswapCoinPublicKey, ContractAddress>
): Uint<128> {
    if (!allowances.member(disclose(owner))) {
        return 0;
    }

    const spenderAllowances = allowances.lookup(disclose(owner));
    if (!spenderAllowances.member(disclose(spender))) {
        return 0;
    }

    return spenderAllowances.lookup(disclose(spender));
}
```

Two-level lookup:

1. **Check if owner exists** in outer Map → return 0 if not
2. **Check if spender exists** in owner's inner Map → return 0 if not
3. **Return amount** if both exist

<Warning>
  **Always check both levels**: Forgetting to check either Map membership can
  cause errors when looking up non-existent keys.
</Warning>

## Approval Patterns

### Infinite Approval

```compact
export circuit approveInfinite(
    spender: Either<ZswapCoinPublicKey, ContractAddress>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;

    _approve(owner, spender, MAX_UINT128);
    return true;
}
```

Setting allowance to MAX_UINT128 means "approve forever":

- **Saves gas**: Users don't need to approve again later
- **Common for trusted contracts**: Official DEX routers, staking contracts
- **Risk**: Spender can always access your tokens (only approve trusted contracts!)

### Increase/Decrease Allowance

```compact
export circuit increaseAllowance(
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    addedValue: Uint<128>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    const current = allowance(owner, spender);

    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(current <= MAX_UINT128 - addedValue, "Allowance overflow");

    _approve(owner, spender, current + addedValue);
    return true;
}

export circuit decreaseAllowance(
    spender: Either<ZswapCoinPublicKey, ContractAddress>,
    subtractedValue: Uint<128>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    const current = allowance(owner, spender);

    assert(current >= subtractedValue, "Decreased below zero");

    _approve(owner, spender, current - subtractedValue);
    return true;
}
```

Safer than direct `approve()` to avoid front-running attacks:

- **Increase**: Add to existing allowance without setting exact amount
- **Decrease**: Subtract from existing allowance
- **Front-run protection**: Prevents race conditions in approval changes

### Revoke Approval

```compact
export circuit revokeApproval(
    spender: Either<ZswapCoinPublicKey, ContractAddress>
): Boolean {
    const owner = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _approve(owner, spender, 0);
    return true;
}
```

Setting allowance to 0 revokes all permissions for that spender.

## Real-World Example

### DEX Trading Flow

```compact
// Step 1: User approves DEX to spend tokens
// Alice: approve(DEX_CONTRACT, 1000)
const alice = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
_approve(alice, DEX_CONTRACT, 1000);

// Step 2: DEX can now transfer Alice's tokens
// (Called by DEX contract in transferFrom - see Allowance tutorial)
const allowed = allowance(alice, DEX_CONTRACT); // Returns 1000

// Step 3: After trade, allowance is reduced
// (See Allowance tutorial for spending allowance)
```

## Try It Yourself

<Accordion title="Build and Test">

**1. Create project:**

```bash
mkdir token-approval && cd token-approval
mkdir -p contracts
```

**2. Save the contract as `contracts/approval.compact`**

**3. Test the approval flow:**

```compact
circuit testApprovals(): [] {
    const alice = left<ZswapCoinPublicKey, ContractAddress>(/* alice's key */);
    const bob = left<ZswapCoinPublicKey, ContractAddress>(/* bob's key */);
    const dex = left<ZswapCoinPublicKey, ContractAddress>(/* dex contract */);

    // Give Alice 1000 tokens
    balances.insert(disclose(alice), 1000);

    // Alice approves DEX to spend 500 tokens
    _approve(alice, dex, 500);

    // Check allowance
    const allowed = allowance(alice, dex);
    assert(allowed == 500, "Allowance mismatch!");

    // Alice also approves Bob to spend 50 tokens
    _approve(alice, bob, 50);

    // Both approvals are independent
    assert(allowance(alice, dex) == 500, "DEX allowance changed!");
    assert(allowance(alice, bob) == 50, "Bob allowance wrong!");
}
```

**4. Compile:**

```bash
compact compile contracts/approval.compact contracts/managed/approval
```

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Allowance & Spending" icon="wallet" href="/basics/allowance">
    Learn how to spend approved tokens
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    Complete token with approvals
  </Card>
</CardGroup>
