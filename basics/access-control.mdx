---
title: "Access Control"
sidebarTitle: "Access Control"
description: "Restrict function access to authorized accounts."
"og:title": "Access Control - Compact by Example"
"og:description": "Owner-only and role-based access control patterns"
---

Control who can call specific functions using authorization checks.

## The Pattern

<Accordion title="View Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Store contract owner
export ledger owner: Either<ZswapCoinPublicKey, ContractAddress>;

// Initialize owner in constructor
circuit constructor(): [] {
    owner = disclose(left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
}

// Owner-only function
export circuit restrictedFunction(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner can call");

    // Protected logic here
}

// Get caller address
export circuit getCaller(): Either<ZswapCoinPublicKey, ContractAddress> {
    return left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
}
```

</Accordion>

## Owner-Only Pattern

### Set Owner in Constructor

```compact
export ledger owner: Either<ZswapCoinPublicKey, ContractAddress>;

circuit constructor(): [] {
    owner = disclose(left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey()));
}
```

The deployer automatically becomes the owner.

### Restrict Function Access

```compact
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Only owner can mint
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner can mint");

    _mint(account, amount);
}
```

Check caller matches owner before executing.

### Transfer Ownership

```compact
export circuit transferOwnership(
    newOwner: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner can transfer");

    owner = disclose(newOwner);
}
```

Allow current owner to transfer to new owner.

## Caller Identification

### Get Caller Address

```compact
// In any circuit
const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
```

`ownPublicKey()` returns the public key of whoever called the circuit.

### Authorize Sender

```compact
export circuit transfer(
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Sender is always the caller
    const from = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Transfer from caller's balance
    _transfer(from, to, amount);
}
```

The caller is automatically authorized to spend their own tokens.

## Role-Based Access

### Multiple Roles

```compact
export ledger owner: Either<ZswapCoinPublicKey, ContractAddress>;
export ledger minter: Either<ZswapCoinPublicKey, ContractAddress>;
export ledger burner: Either<ZswapCoinPublicKey, ContractAddress>;

// Owner can mint and burn
export circuit mint(account: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner || caller == minter, "Not authorized to mint");
    _mint(account, amount);
}

export circuit burn(amount: Uint<128>): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner || caller == burner, "Not authorized to burn");
    _burn(caller, amount);
}
```

Different roles for different operations.

### Admin Functions

```compact
export circuit setMinter(newMinter: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");

    minter = disclose(newMinter);
}

export circuit setBurner(newBurner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");

    burner = disclose(newBurner);
}
```

Owner manages role assignments.

## Common Patterns

### Ownable Modifier Pattern

```compact
// Reusable authorization check
circuit requireOwner(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");
}

export circuit restrictedFunction(): [] {
    requireOwner();
    // Protected logic
}
```

Extract the check into a reusable function.

### Pausable Pattern

```compact
export ledger paused: Boolean;

export circuit pause(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");
    paused = disclose(true);
}

export circuit unpause(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");
    paused = disclose(false);
}

export circuit transfer(to: Either<ZswapCoinPublicKey, ContractAddress>, amount: Uint<128>): [] {
    assert(!paused, "Contract is paused");
    // Transfer logic
}
```

Owner can pause/unpause contract operations.

### Renounce Ownership

```compact
export circuit renounceOwnership(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner");

    // Set to zero address (no one owns it)
    owner = disclose(left<ZswapCoinPublicKey, ContractAddress>(default<ZswapCoinPublicKey>));
}
```

Permanently remove owner control (irreversible).

## Security Considerations

**Always check authorization first**:

```compact
// ✅ Good: Check before action
const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
assert(caller == owner, "Only owner");
dangerousAction();

// ❌ Bad: Action before check
dangerousAction();
assert(caller == owner, "Only owner"); // Too late!
```

**Use clear error messages**:

```compact
assert(caller == owner, "Only owner can mint"); // Clear
assert(caller == owner, "Unauthorized"); // Less clear
```

## What's Next

<CardGroup cols={2}>
  <Card title="Minting" icon="plus" href="/basics/minting">
    Apply access control to minting
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    See access control in complete token
  </Card>
</CardGroup>
