---
title: "Minting & Burning"
sidebarTitle: "Minting & Burning"
description: "Learn token supply management in Compact. Master minting new tokens and burning existing ones while maintaining total supply integrity and overflow safety."
"og:title": "Minting & Burning Tutorial - Compact Token Supply"
"og:description": "Master token supply management with safe minting and burning operations"
---

<Info>
  **What You'll Learn**: Minting tokens • Burning tokens • Total supply tracking
  • Overflow protection • Access control
</Info>

## Introduction

Minting creates new tokens and adds them to circulation. Burning permanently destroys tokens, removing them from circulation. Together, they control the token supply - essential for inflationary tokens, rewards systems, stablecoins, or any economy that needs to adjust supply.

<Tip>
  **Real-world use**: Reward tokens (mint for achievements), stablecoins
  (mint/burn to maintain peg), governance tokens (burn for buybacks), NFT
  creation, or deflationary tokenomics.
</Tip>

## The Contract

<Accordion title="View Contract Code">

```compact
pragma language_version >= 0.17.0;

import CompactStandardLibrary;

// Account balances
export ledger balances: Map<Either<ZswapCoinPublicKey, ContractAddress>, Uint<128>>;

// Total token supply
export ledger totalSupply: Uint<128>;

// Get total circulating supply
export circuit getTotalSupply(): Uint<128> {
    return totalSupply;
}

// Mint new tokens
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    _mint(account, amount);
}

// Burn your own tokens
export circuit burn(amount: Uint<128>): [] {
    const account = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _burn(account, amount);
}

// Burn tokens from another account (with approval)
export circuit burnFrom(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    const spender = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Check and spend allowance (if using approval system)
    // _spendAllowance(account, spender, amount);

    _burn(account, amount);
}

// Internal: Mint tokens
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(!isZeroAddress(account), "Mint to zero address");

    // Check total supply won't overflow
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(totalSupply <= MAX_UINT128 - amount, "Total supply overflow");

    // Update total supply
    totalSupply = disclose(totalSupply + amount);

    // Get current balance
    const currentBalance = getBalance(account);

    // Check account balance won't overflow
    assert(currentBalance <= MAX_UINT128 - amount, "Balance overflow");

    // Increase account balance
    balances.insert(disclose(account), disclose(currentBalance + amount));
}

// Internal: Burn tokens
circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(!isZeroAddress(account), "Burn from zero address");

    // Get current balance
    const currentBalance = getBalance(account);

    // Check sufficient balance
    assert(currentBalance >= amount, "Burn amount exceeds balance");

    // Decrease account balance
    balances.insert(disclose(account), disclose(currentBalance - amount));

    // Decrease total supply
    totalSupply = disclose(totalSupply - amount);
}

// Helper: Get balance
circuit getBalance(account: Either<ZswapCoinPublicKey, ContractAddress>): Uint<128> {
    if (!balances.member(disclose(account))) {
        return 0;
    }
    return balances.lookup(disclose(account));
}

// Helper: Check zero address
circuit isZeroAddress(addr: Either<ZswapCoinPublicKey, ContractAddress>): Boolean {
    return false; // Placeholder
}
```

</Accordion>

## How It Works

### Total Supply Tracking

```compact
export ledger totalSupply: Uint<128>;

export circuit getTotalSupply(): Uint<128> {
    return totalSupply;
}
```

Total supply represents all tokens in circulation:

- **Mint**: Increases total supply
- **Burn**: Decreases total supply
- **Transfer**: Doesn't change total supply (moves between accounts)

<Note>
  **Invariant**: `sum(all balances) == totalSupply` should always be true. Mint
  and burn are the only operations that change this.
</Note>

### Minting Tokens

```compact
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(!isZeroAddress(account), "Mint to zero address");

    // Check total supply won't overflow
    const MAX_UINT128 = 340282366920938463463374607431768211455 as Uint<128>;
    assert(totalSupply <= MAX_UINT128 - amount, "Total supply overflow");

    // Update total supply
    totalSupply = disclose(totalSupply + amount);

    // Get current balance
    const currentBalance = getBalance(account);

    // Check account balance won't overflow
    assert(currentBalance <= MAX_UINT128 - amount, "Balance overflow");

    // Increase account balance
    balances.insert(disclose(account), disclose(currentBalance + amount));
}
```

Minting flow:

1. **Validate recipient**: Don't mint to zero address
2. **Check total supply overflow**: Ensure we don't exceed Uint\<128\> max
3. **Increase total supply**: Add new tokens to circulation
4. **Check account overflow**: Ensure recipient balance won't overflow
5. **Credit account**: Add tokens to recipient's balance

**Result**: New tokens are created from nothing and added to an account.

<Warning>
  **Critical**: Always check BOTH total supply overflow AND account balance
  overflow. Forgetting either can corrupt state.
</Warning>

### Burning Tokens

```compact
circuit _burn(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(!isZeroAddress(account), "Burn from zero address");

    // Get current balance
    const currentBalance = getBalance(account);

    // Check sufficient balance
    assert(currentBalance >= amount, "Burn amount exceeds balance");

    // Decrease account balance
    balances.insert(disclose(account), disclose(currentBalance - amount));

    // Decrease total supply
    totalSupply = disclose(totalSupply - amount);
}
```

Burning flow:

1. **Validate account**: Don't burn from zero address
2. **Check sufficient balance**: Ensure account has tokens to burn
3. **Decrease account balance**: Remove tokens from account
4. **Decrease total supply**: Remove tokens from circulation

**Result**: Tokens are permanently destroyed and removed from total supply.

<Tip>
  **Order matters**: Decrease balance BEFORE total supply. If the balance check
  fails, we haven't corrupted total supply yet.
</Tip>

### Public vs Internal Functions

```compact
// Public: Anyone can call (but should add access control)
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    _mint(account, amount);
}

// Internal: Only callable within contract
circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // ... minting logic
}
```

- **Public functions** (`export circuit`): Can be called externally - add access control!
- **Internal functions** (no `export`): Only used within the contract

<Warning>
  **Security Risk**: The example `mint()` function has NO access control. Anyone
  can mint tokens! See the challenge section for how to fix this.
</Warning>

### Burning Your Own Tokens

```compact
export circuit burn(amount: Uint<128>): [] {
    const account = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    _burn(account, amount);
}
```

Users can always burn their own tokens:

- **`ownPublicKey()`**: Automatically gets caller's address
- **Self-burn**: No approval needed to burn your own tokens
- **Deflationary**: Reduces circulating supply permanently

### Delegated Burning

```compact
export circuit burnFrom(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    const spender = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());

    // Check allowance (requires approval system)
    _spendAllowance(account, spender, amount);

    _burn(account, amount);
}
```

Burn someone else's tokens (with their approval):

- Useful for contracts that burn tokens as part of their logic
- Requires the approval pattern (see Approval & Allowance tutorial)

## Supply Management Patterns

### Capped Supply

```compact
export ledger MAX_SUPPLY: Uint<128>;

circuit constructor(): [] {
    MAX_SUPPLY = disclose(1000000 as Uint<128>); // Max 1 million tokens
}

circuit _mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    assert(!isZeroAddress(account), "Mint to zero address");

    // Check against max supply cap
    assert(totalSupply + amount <= MAX_SUPPLY, "Exceeds max supply");

    // ... rest of minting logic
}
```

Enforce a hard cap on total supply (like Bitcoin's 21 million).

### Inflationary Tokenomics

```compact
export ledger lastInflation: Uint<64>;
export ledger inflationRate: Uint<8>; // Percentage

export circuit applyInflation(): [] {
    // Calculate time since last inflation
    const timePassed = getCurrentTime() - lastInflation;
    const DAY_IN_SECONDS = 86400 as Uint<64>;

    if (timePassed >= DAY_IN_SECONDS) {
        // Mint new tokens (e.g., 2% daily inflation)
        const inflation = (totalSupply * inflationRate as Uint<128>) / 100;

        const treasury = getTreasuryAddress();
        _mint(treasury, inflation);

        lastInflation = disclose(getCurrentTime());
    }
}
```

Automatic inflation for staking rewards or incentive programs.

### Deflationary on Transfer

```compact
export ledger burnRate: Uint<8>; // Percentage burned per transfer

circuit _transfer(
    from: Either<ZswapCoinPublicKey, ContractAddress>,
    to: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    // Calculate burn amount (e.g., 1% of transfer)
    const burnAmount = (amount * burnRate as Uint<128>) / 100;
    const transferAmount = amount - burnAmount;

    // Burn the fee
    _burn(from, burnAmount);

    // Transfer the rest
    const fromBalance = getBalance(from);
    const toBalance = getBalance(to);

    balances.insert(disclose(from), disclose(fromBalance - transferAmount));
    balances.insert(disclose(to), disclose(toBalance + transferAmount));
}
```

Some tokens burn a percentage of each transfer (deflationary pressure).

## Try It Yourself

<Accordion title="Build and Test">

**1. Create project:**

```bash
mkdir supply-management && cd supply-management
mkdir -p contracts
```

**2. Save the contract as `contracts/supply.compact`**

**3. Test minting and burning:**

```compact
circuit testSupply(): [] {
    const alice = left<ZswapCoinPublicKey, ContractAddress>(/* alice's key */);
    const bob = left<ZswapCoinPublicKey, ContractAddress>(/* bob's key */);

    // Mint 1000 tokens to Alice
    _mint(alice, 1000);
    // Total supply: 1000, Alice: 1000

    // Mint 500 tokens to Bob
    _mint(bob, 500);
    // Total supply: 1500, Bob: 500

    // Alice burns 200 tokens
    _burn(alice, 200);
    // Total supply: 1300, Alice: 800

    // Verify supply matches sum of balances
    const sum = getBalance(alice) + getBalance(bob);
    assert(sum == totalSupply, "Supply mismatch!");
}
```

**4. Compile:**

```bash
compact compile contracts/supply.compact contracts/managed/supply
```

</Accordion>

### Challenge: Add Owner-Only Minting

<Accordion title="View Solution">

Only allow specific addresses to mint tokens:

```compact
// Owner address
export ledger owner: Either<ZswapCoinPublicKey, ContractAddress>;

circuit constructor(initialOwner: Either<ZswapCoinPublicKey, ContractAddress>): [] {
    owner = disclose(initialOwner);
    totalSupply = disclose(0);
}

// Modifier: Only owner can call
circuit onlyOwner(): [] {
    const caller = left<ZswapCoinPublicKey, ContractAddress>(ownPublicKey());
    assert(caller == owner, "Only owner can call this");
}

// Protected mint function
export circuit mint(
    account: Either<ZswapCoinPublicKey, ContractAddress>,
    amount: Uint<128>
): [] {
    onlyOwner(); // Check authorization
    _mint(account, amount);
}

// Transfer ownership
export circuit transferOwnership(
    newOwner: Either<ZswapCoinPublicKey, ContractAddress>
): [] {
    onlyOwner();
    assert(!isZeroAddress(newOwner), "New owner is zero address");
    owner = disclose(newOwner);
}
```

Now only the owner can mint tokens, preventing unauthorized inflation.

</Accordion>

## What's Next

<CardGroup cols={2}>
  <Card title="Mappings" icon="database" href="/basics/mappings">
    Back to Map storage basics
  </Card>
  <Card title="ERC20 Token" icon="coins" href="/applications/erc20-token">
    Complete token with all features
  </Card>
</CardGroup>
